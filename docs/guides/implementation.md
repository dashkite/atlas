# Implementation Guide

*Atlas*

## The Algorithm

The high-level algorithm is expressed in the `generate` function itself:

```coffeescript
generate = ( entries, map ) ->
  map = if map? then Map.from map else Map.make()
  for await dependency from analyze entries
    await Map.add map, dependency
  map
```

There are two high-level interfaces here:

- `analyze`: performs a dependency analysis on the given entry points and returns a generator producing dependency objects, which include module and import information.
- `Map.add`: adds a dependency to a map.

The analyze phase uses esbuild to generate a list of dependencies, one per import. We add the module information for the dependency during this phase as well.

For each dependency, we try the configured mapping generators until we get a match, and then invoke the corresponding decorator.



The code for this might look something like this:

```coffeescript
generate = ( entries, map ) ->
  map = if map? then Map.from map else Make.make()
  for await dependency from analyze entries
    if ( provider = Generators.find { entries, dependency })?
      dependency = await provider.apply dependency
      Map.add map, dependency
    else
      throw new Error "No mapping generator found
				for [ #{ dependency.source.path }]"
  map
```

## The Analyzer

There are two parts to the analyze phase:

- The dependency analysis itself.
- The dependency normalization, which incorporates module data.

The dependency analysis is based on the data generated by esbuild. Although we don’t use esbuild as a bundler, it’s the most effective static analysis tool available. We’ll eventually break this piece out into its own module.

The normalization phase is effectively a wrapper around the static analyzer. We load the module data, which adds a bit of overhead to the analysis phase but is necessary in order to generate the correct URLs.

## Mapping Generators

We have three mapping generators:

- The production CDN provider, which generates mappings for `node_modules` dependencies. Right now, we only support the JSDelivr CDN.
- The local provider, which generates mappings for dependencies in the same source tree as an entry point.
- The Sky provider, which generates mappings for linked dependencies, using the file hash and Sky environment to generate the URL.

The generator must produce a mapping object, which consists of three properties:

- `scope`: a URL or URL stub.
- `specifier`: a module specifier or a (possibly relative) URL.
- `target`: a URL corresponding to the module resource.

Generators can typically generate the specifier and target from the dependency context. However, the scope presents a difficulty because the scope URL is the target of the dependency’s scope, not the dependency itself, and the scope is not itself a dependency.  Specifically, scopes don’t have an import specifier. Thus, generators must allow for dependency for which there’s no import specifier available. 